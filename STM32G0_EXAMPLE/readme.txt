/*==============================================================================
 @FILE: readme.txt
 @AUTHOR: maxmklam
 @OWNER: maxmklam
 @DESCRIBE: 
 Copyright (c) 2024 maxmklam 
 
 This file describes the use of projects STM32G030F6_VSP_MASTER_EXAMPLE and STM32G030F6_VSP_CLIENT_EXAMPLE for VSP transmission and reception example.
 The project is opened with IAR 9.xx
 
 Structure of folder/file:
 myLIB\ -- Contains all platform independent files which implement a blocking time delay function (in us resolution), and a non-blocking time elapse measurement function (in us resolution).
 VSP\ -- Contains all platform independent files which implement all the VSP transmission and reception functions.
 Core\ -- Contains platform dependent files and main() generated by STM32CUBEMX, most are peripheral control related.
 Drivers\ -- Driver files for STM32G0 MCUs generated by STM32CUBEMX.
 myCode_MCU\ -- Additional platform dependent files for that specific MCU of the project.
 myCode_MCU\VSP_4_MCU\ -- Contains platform dependent files for the VSP\ folder.
 myCode_STM32G0\ -- Contains all the platform dependent files commonly accessible for all STM32G0 series MCU for all projects.
 myCode_STM32G0\myLIB_4_STM32G0\ -- Contains platform dependent files for the myLIB\ folder commonly accessible for all STM32G0 series MCU for all projects.
==============================================================================*/

Approach 1:
------------------------
On master side, transmission using SPI + DMA
On client side, reception using TIMER input capture + DMA

How to enable:
in STM32G030F6_VSP_MASTER_EXAMPLE\myCode_MCU\VSP_4_MCU\VSP_4_MCU.h, 
#define  VSP_TX_USED_SPI  1 //0: VSP_TX_USED_TMR

   __________________________                       __________________________
  |         |    VSP tx      |                      |    VSP rx     |         |
  |         |                |                      |               |         |
  |         | SPI2 MOSI(PA.4)|--------------------->|TIM1 CC1(PA.8) |         |
  |         |                |                      |               |         |
  |         |                |                      |               |         |
  |         |                |                      |               |         |
  |         |                |                      |               |         |
  |         |                |                      |               |         |
  |         |________________|                      |_______________|         |
  |                          |                      |                         |
  |                          |                      |                         |
  |    STM32G030F6 master    |                      |    STM32G030F6 client   |
  |                       GND|______________________|GND                      |
  |                          |                      |                         |
  |__________________________|                      |_________________________|



How the VSP transmission using SPI + DMA works:
Raw data (max 128 bytes) is passed into VSP_TX_data2bmc_encode_spi(), encoded in BMC format bit by bit, then packed byte by byte and saved in bmcTxBuff[] and sent by SPI MOSI pin through DMA

Data flow between the VSP Tx and Rx:
  128 bytes random raw data       max 306 bytes       max 1924 bytes        128 bytes random raw data
  --------------------------     ---------------     ------------------     --------------------------
       txRawBuff[]  ------------>  bmcTxBuff[]   ---->  bmcRxBuff[]  ----------->  rxRawBuff[]


For example, byte to sent: 0, 1, 2, 3
1.txRawBuff[] = 0, 1, 2, 3
2.encoded to BMC format: B 1110111 000 10 111 01 00 111 01 01 0000
                           ------- --- -- --- ----- --- ----- ----
                             FS    NF  1  NF   1 0  NF   1 1  FE

3.pack the encoded binary bit to byte, and saved in bmcTxBuff[] = 11101110 00101110 10011101 01000011 (it requires 4 bytes of buffer size)
4.transmit the bmcTxBuff[] bits using SPI.
5.Tx waveform seen on the Rx pin: 
  ________   ___     _   ___   _    ___   _   _      ________
          | |   |   | | |   | | |  |   | | | | |    |
          |_|   |___| |_|   |_| |__|   |_| |_| |____|

6.on receiver side, the Tx waveform captured and saved in bmcRxBuff[] by DMA automatically by the TIMER input capture pin as below (assume TIMER clock is 64MHz, SPI is operated at 4MHz, width of one pulse = 64/4 = 16):
    48, 16, 48, 48, 16, 16, 48, 16, 16, 32, 48, 16, 16, 64 
    ----------- --- ------- --- ------  --- --- ------- ---
        FS      NF     1    NF    1     0   NF   1  1   FE

7.Decode the received waveform value and we got bytes: 0, 1, 2, 3, and finally saved to rxRawBuff[]





Approach 2:
------------------------
On master side, transmission using TIMER output compare + DMA
On client side, reception using TIMER input capture + DMA

How to enable:
in STM32G030F6_VSP_MASTER_EXAMPLE\myCode_MCU\VSP_4_MCU\VSP_4_MCU.h, 
#define  VSP_TX_USED_SPI  0 //0: VSP_TX_USED_TMR

   __________________________                       __________________________
  |         |    VSP tx      |                      |    VSP rx     |         |
  |         |                |                      |               |         |
  |         | TIM16 CC1(PA.6)|--------------------->|TIM1 CC1(PA.8) |         |
  |         |                |                      |               |         |
  |         |                |                      |               |         |
  |         |                |                      |               |         |
  |         |                |                      |               |         |
  |         |                |                      |               |         |
  |         |________________|                      |_______________|         |
  |                          |                      |                         |
  |                          |                      |                         |
  |    STM32G030F6 master    |                      |    STM32G030F6 client   |
  |                       GND|______________________|GND                      |
  |                          |                      |                         |
  |__________________________|                      |_________________________|



How the VSP transmission using TIMER output compare + DMA works:
Raw data (max 128 bytes) is passed into VSP_TX_data2bmc_encode_tmr(), encoded in BMC format, one BMC bit requires one byte to represent, then saved in bmcTxBuff[] and sent by TIMER output compare pin by force active mode through DMA.
In this approach, because one BMC bit needed one byte of data, that's why the bmcTxBuff[] buffer size is much larger than using SPI approach.
Data contained in bmcTxBuff[] are look likes: 0x48, 0x58 which is written to TIMER register: CCMR1 to make the TIMER output compare pin become "low" or "high" respectively. Using this approach to continuously output BMC waveform on the TIMER output compare pin.


Data flow between the VSP Tx and Rx:
  128 bytes random raw data       max 2442 bytes       max 1924 bytes        128 bytes random raw data
  --------------------------     ---------------     ------------------     --------------------------
       txRawBuff[]  ------------>  bmcTxBuff[]   ---->  bmcRxBuff[]  ----------->  rxRawBuff[]

For example, byte to sent: 0, 1, 2, 3
1.txRawBuff[] = 0, 1, 2, 3
2.encoded to BMC format: B 1110111 000 10 111 01 00 111 01 01 0000
                           ------- --- -- --- ----- --- ----- ----
                             FS    NF  1  NF   1 0  NF   1 1  FE

3.replace BMC bit "1" by "0x58", "0" by "0x48", and saved in bmcTxBuff[] = 0x58,0x58,0x58, 0x48, 0x58,0x58,0x58, 0x48,0x48,0x48, 0x58,0x48, 0x58,0x58,0x58, 0x48,0x58, 0x48,0x48, 0x58,0x58,0x58, 0x48,0x58, 0x48,0x58, 0x48,0x48,0x48,0x48 (it requires 30 bytes of buffer size)
4.transmit the bmcTxBuff[] bits using TIMER output compare function force active mode.
5.Tx waveform seen on the Rx pin: 
  ________   ___     _   ___   _    ___   _   _      ________
          | |   |   | | |   | | |  |   | | | | |    |
          |_|   |___| |_|   |_| |__|   |_| |_| |____|

6.on receiver side, the Tx waveform captured and saved in bmcRxBuff[] by DMA automatically by the TIMER input capture pin as below (assume TIMER clock is 64MHz, TIMER period is operated at 4MHz, width of one pulse = 64/4 = 16):
    48, 16, 48, 48, 16, 16, 48, 16, 16, 32, 48, 16, 16, 64 
    ----------- --- ------- --- ------  --- --- ------- ---
        FS      NF     1    NF    1     0   NF   1  1   FE

7.Decode the received waveform value and we got bytes: 0, 1, 2, 3, and finally saved to rxRawBuff[]







VSP Tx/Rx full duplex:
------------------------
Basically both STM32G030F6_VSP_MASTER_EXAMPLE and STM32G030F6_VSP_CLIENT_EXAMPLE support VSP tx/rx, however, due to limits of RAM size, VSP tx/rx can't be enabled in one MCU at the same time.
So you can only just select tx or rx each time, in STM32G030F6_VSP_MASTER_EXAMPLE\myCode_MCU\VSP_4_MCU\VSP_4_MCU.h and STM32G030F6_VSP_CLIENT_EXAMPLE\myCode_MCU\VSP_4_MCU\VSP_4_MCU.h

#define  VSP_TX_ENABLE  1
#define  VSP_RX_ENABLE  0


If you really want to do VSP tx/rx in the same MCU, you can reduce the TXRAWBUFF_SIZE and RXRAWBUFF_SIZE. Currently maximum buffer size for transmitting/receiving raw data is set to 128 byte.
 
//With support 128 bytes raw data
//----------------------------------------------
 #define  TXRAWBUFF_SIZE  128
 #define  RXRAWBUFF_SIZE  128

 #define  BMCTXBUFF4SPI_SIZE  308 //max need 306 when TXRAWBUFF_SIZE is 128
 #define  BMCTXBUFF4TMR_SIZE  2444 //max need 2442 when TXRAWBUFF_SIZE is 128
 #define  BMCRXBUFF_SIZE  1940 //max need 1924 when TXRAWBUFF_SIZE is 128
//----------------------------------------------





